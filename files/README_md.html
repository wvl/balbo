<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>README.md</li>
            <li>Last modified: Tue Oct 27 16:24:43 -0700 2009</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <h1>Mustache</h1>

<p>Inspired by <a href="http://code.google.com/p/google-ctemplate/">ctemplate</a> and <a href="http://www.ivan.fomichev.name/2008/05/erlang-template-engine-prototype.html">et</a>, Mustache is a
framework-agnostic way to render logic-free views.</p>

<p>As ctemplates says, "It emphasizes separating logic from presentation:
it is impossible to embed application logic in this template language."</p>

<h2>Overview</h2>

<p>Think of Mustache as a replacement for your views. Instead of views
consisting of ERB or HAML with random helpers and arbitrary logic,
your views are broken into two parts: a Ruby class and an HTML
template.</p>

<p>We call the Ruby class the "view" and the HTML template the
"template."</p>

<p>All your logic, decisions, and code is contained in your view. All
your markup is contained in your template. The template does nothing
but reference methods in your view.</p>

<p>This strict separation makes it easier to write clean templates,
easier to test your views, and more fun to work on your app's front end.</p>

<h2>Why?</h2>

<p>I like writing Ruby. I like writing HTML. I like writing JavaScript.</p>

<p>I don't like writing ERB, Haml, Liquid, Django Templates, putting Ruby
in my HTML, or putting JavaScript in my HTML.</p>

<h2>Usage</h2>

<p>Quick example:</p>

<pre><code>&gt;&gt; require 'mustache'
=&gt; true
&gt;&gt; Mustache.render("Hello {{planet}}", :planet =&gt; "World!")
=&gt; "Hello World!"
</code></pre>

<p>We've got an <code>examples</code> folder but here's the canonical one:</p>

<pre><code>class Simple &lt; Mustache
  def name
    "Chris"
  end

  def value
    10_000
  end

  def taxed_value
    value - (value * 0.4)
  end

  def in_ca
    true
  end
end
</code></pre>

<p>We simply create a normal Ruby class and define methods. Some methods
reference others, some return values, some return only booleans.</p>

<p>Now let's write the template:</p>

<pre><code>Hello {{name}}
You have just won ${{value}}!
{{#in_ca}}
Well, ${{taxed_value}}, after taxes.
{{/in_ca}}
</code></pre>

<p>This template references our view methods. To bring it all together,
here's the code to render actual HTML;</p>

<pre><code>Simple.render
</code></pre>

<p>Which returns the following:</p>

<pre><code>Hello Chris
You have just won $10000!
Well, $6000.0, after taxes.
</code></pre>

<p>Simple.</p>

<h2>Tag Types</h2>

<p>Tags are indicated by the double mustaches. <code>{{name}}</code> is a tag. Let's
talk about the different types of tags.</p>

<h3>Variables</h3>

<p>The most basic tag is the variable. A <code>{{name}}</code> tag in a basic
template will try to call the <code>name</code> method on your view. If there is
no <code>name</code> method, an exception will be raised.</p>

<p>All variables are HTML escaped by default. If you want to return
unescaped HTML, use the triple mustache: <code>{{{name}}}</code>.</p>

<p>By default a variable "miss" returns an empty string. You can
configure this by setting <code>Mustache.raise_on_context_miss</code> to true.</p>

<h3>Boolean Sections</h3>

<p>A section begins with a pound and ends with a slash. That is,
<code>{{#person}}</code> begins a "person" section while <code>{{/person}}</code> ends it.</p>

<p>If the <code>person</code> method exists and calling it returns false, the HTML
between the pound and slash will not be displayed.</p>

<p>If the <code>person</code> method exists and calling it returns true, the HTML
between the pound and slash will be rendered and displayed.</p>

<h3>Enumerable Sections</h3>

<p>Enumerable sections are syntactically identical to boolean sections in
that they begin with a pound and end with a slash. The difference,
however, is in the view: if the method called returns an enumerable,
the section is repeated as the enumerable is iterated over.</p>

<p>Each item in the enumerable is expected to be a hash which will then
become the context of the corresponding iteration. In this way we can
construct loops.</p>

<p>For example, imagine this template:</p>

<pre><code>{{#repo}}
  &lt;b&gt;{{name}}&lt;/b&gt;
{{/repo}}
</code></pre>

<p>And this view code:</p>

<pre><code>def repo
  Repository.all.map { |r| { :name =&gt; r.to_s } }
end
</code></pre>

<p>When rendered, our view will contain a list of all repository names in
the database.</p>

<p>As a convenience, if a section returns a hash (as opposed to an array
or a boolean) it will be treated as a single item array.</p>

<p>With the above template, we could use this Ruby code for a single
iteration:</p>

<pre><code>def repo
  { :name =&gt; Repository.first.to_s }
end
</code></pre>

<p>This would be treated by Mustache as functionally equivalent to the
following:</p>

<pre><code>def repo
  [ { :name =&gt; Repository.first.to_s } ]
end
</code></pre>

<h3>Comments</h3>

<p>Comments begin with a bang and are ignored. The following template:</p>

<pre><code>&lt;h1&gt;Today{{! ignore me }}.&lt;/h1&gt;
</code></pre>

<p>Will render as follows:</p>

<pre><code>&lt;h1&gt;Today.&lt;/h1&gt;
</code></pre>

<h3>Partials</h3>

<p>Partials begin with a less than sign, like <code>{{&lt; box}}</code>.</p>

<p>If a partial's view is loaded, we use that to render the HTML. If
nothing is loaded we render the template directly using our current context.</p>

<p>In this way partials can reference variables or sections the calling
view defines.</p>

<h3>Set Delimiter</h3>

<p>Set Delimiter tags start with an equal sign and change the tag
delimiters from {{ and }} to custom strings.</p>

<p>Consider the following contrived example:</p>

<pre><code>* {{ default_tags }}
{{=&lt;% %&gt;=}}
* &lt;% erb_style_tags %&gt;
&lt;%={{ }}=%&gt;
* {{ default_tags_again }}
</code></pre>

<p>Here we have a list with three items. The first item uses the default
tag style, the second uses erb style as defined by the Set Delimiter
tag, and the third returns to the default style after yet another Set
Delimiter declaration.</p>

<p>According to <a href="http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html">ctemplates</a>, this "is useful for languages like TeX, where
double-braces may occur in the text and are awkward to use for
markup."</p>

<p>Custom delimiters may not contain whitespace or the equals sign.</p>

<h2>Dict-Style Views</h2>

<p>ctemplate and friends want you to hand a dictionary to the template
processor. Mustache supports a similar concept. Feel free to mix the
class-based and this more procedural style at your leisure.</p>

<p>Given this template (winner.mustache):</p>

<pre><code>Hello {{name}}
You have just won ${{value}}!
</code></pre>

<p>We can fill in the values at will:</p>

<pre><code>view = Winner.new
view[:name] = 'George'
view[:value] = 100
view.render
</code></pre>

<p>Which returns:</p>

<pre><code>Hello George
You have just won $100!
</code></pre>

<p>We can re-use the same object, too:</p>

<pre><code>view[:name] = 'Tony'
view.render
Hello Tony
You have just won $100!
</code></pre>

<h2>Templates</h2>

<p>A word on templates. By default, a view will try to find its template
on disk by searching for an HTML file in the current directory that
follows the classic Ruby naming convention.</p>

<pre><code>TemplatePartial =&gt; ./template_partial.mustache
</code></pre>

<p>You can set the search path using <code>Mustache.template_path</code>. It can be set on a
class by class basis:</p>

<pre><code>class Simple &lt; Mustache
  self.template_path = File.dirname(__FILE__)
  ... etc ...
end
</code></pre>

<p>Now <code>Simple</code> will look for <code>simple.mustache</code> in the directory it resides
in, no matter the cwd.</p>

<p>If you want to just change what template is used you can set
<code>Mustache.template_file</code> directly:</p>

<pre><code>Simple.template_file = './blah.mustache'
</code></pre>

<p>Mustache also allows you to define the extension it'll use.</p>

<pre><code>Simple.template_extension = 'xml'
</code></pre>

<p>Given all other defaults, the above line will cause Mustache to look
for './blah.xml'</p>

<p>Feel free to set the template directly:</p>

<pre><code>Simple.template = 'Hi {{person}}!'
</code></pre>

<p>Or set a different template for a single instance:</p>

<pre><code>Simple.new.template = 'Hi {{person}}!'
</code></pre>

<p>Whatever works.</p>

<h2>Views</h2>

<p>Mustache supports a bit of magic when it comes to views. If you're
authoring a plugin or extension for a web framework (Sinatra, Rails,
etc), check out the <code>view_namespace</code> and <code>view_path</code> settings on the
<code>Mustache</code> class. They will surely provide needed assistance.</p>

<h2>Helpers</h2>

<p>What about global helpers? Maybe you have a nifty <code>gravatar</code> function
you want to use in all your views? No problem.</p>

<p>This is just Ruby, after all.</p>

<pre><code>module ViewHelpers
  def gravatar(email, size = 30)
    gravatar_id = Digest::MD5.hexdigest(email.to_s.strip.downcase)
    gravatar_for_id(gravatar_id, size)
  end

  def gravatar_for_id(gid, size = 30)
    "#{gravatar_host}/avatar/#{gid}?s=#{size}"
  end

  def gravatar_host
    @ssl ? 'https://secure.gravatar.com' : 'http://www.gravatar.com'
  end
end
</code></pre>

<p>Then just include it:</p>

<pre><code>class Simple &lt; Mustache
  include ViewHelpers

  def name
    "Chris"
  end

  def value
    10_000
  end

  def taxed_value
    value - (value * 0.4)
  end

  def in_ca
    true
  end
end
</code></pre>

<p>Great, but what about that <code>@ssl</code> ivar in <code>gravatar_host</code>? There are
many ways we can go about setting it.</p>

<p>Here's on example which illustrates a key feature of Mustache: you
are free to use the <code>initialize</code> method just as you would in any
normal class.</p>

<pre><code>class Simple &lt; Mustache
  include ViewHelpers

  def initialize(ssl = false)
    @ssl = ssl
  end

  ... etc ...
end
</code></pre>

<p>Now:</p>

<pre><code>Simple.new(request.ssl?).render
</code></pre>

<p>Convoluted but you get the idea.</p>

<h2>Sinatra</h2>

<p>Mustache ships with Sinatra integration. Please see
<code>lib/mustache/sinatra.rb</code> or
<a href="http://defunkt.github.com/mustache/classes/Mustache/Sinatra.html">http://defunkt.github.com/mustache/classes/Mustache/Sinatra.html</a> for
complete documentation.</p>

<p>An example Sinatra application is also provided:
<a href="http://github.com/defunkt/mustache-sinatra-example">http://github.com/defunkt/mustache-sinatra-example</a></p>

<h2><a href="http://github.com/brynary/rack-bug/">Rack::Bug</a></h2>

<p>Mustache also ships with a <code>Rack::Bug</code> panel. In your <code>config.ru</code> add
the following code:</p>

<pre><code>require 'rack/bug/panels/mustache_panel'
use Rack::Bug::MustachePanel
</code></pre>

<p>Using Rails? Add this to your initializer or environment file:</p>

<pre><code>require 'rack/bug/panels/mustache_panel'
config.middleware.use "Rack::Bug::MustachePanel"
</code></pre>

<p><a href="http://img.skitch.com/20091027-n8pxwwx8r61tc318a15q1n6m14.png"><img src="http://img.skitch.com/20091027-xyf4h1yxnefpp7usyddrcmc7dn.png" alt="Rack::Bug" /></a></p>

<h2>Vim</h2>

<p>Thanks to <a href="http://github.com/juvenn">Juvenn Woo</a> for mustache.vim. It
is included under the contrib/ directory.</p>

<h2>Emacs</h2>

<p>tpl-mode.el is included under the contrib/ directory for any Emacs users.
Based on Google's tpl-mode for ctemplates, it adds support for Mustache's
more lenient tag values and includes a few commands for your editing pleasure.</p>

<h2>Installation</h2>

<h3><a href="http://gemcutter.org/">Gemcutter</a></h3>

<pre><code>$ gem install mustache
</code></pre>

<h3><a href="http://hellorip.com">Rip</a></h3>

<pre><code>$ rip install git://github.com/defunkt/mustache.git
</code></pre>

<h2>Acknowledgements</h2>

<p>Thanks to <a href="http://github.com/mojombo">Tom Preston-Werner</a> for showing
me ctemplate and <a href="http://github.com/leah">Leah Culver</a> for the name "Mustache."</p>

<h2>Meta</h2>

<ul>
<li>Code: <code>git clone git://github.com/defunkt/mustache.git</code></li>
<li>Home: <a href="http://github.com/defunkt/mustache">http://github.com/defunkt/mustache</a></li>
<li>Docs: <a href="http://defunkt.github.com/mustache">http://defunkt.github.com/mustache</a></li>
<li>Bugs: <a href="http://github.com/defunkt/mustache/issues">http://github.com/defunkt/mustache/issues</a></li>
<li>List: <a href="http://groups.google.com/group/mustache-rb">http://groups.google.com/group/mustache-rb</a></li>
<li>Test: <a href="http://runcoderun.com/defunkt/mustache">http://runcoderun.com/defunkt/mustache</a></li>
<li>Gems: <a href="http://gemcutter.org/gems/mustache">http://gemcutter.org/gems/mustache</a></li>
<li>Boss: Chris Wanstrath :: <a href="http://github.com/defunkt">http://github.com/defunkt</a></li>
</ul>

<script type="text/javascript">$(function() {
  $('a').each(function() { $(this).attr('target', '_blank') })
})</script>

    </div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>